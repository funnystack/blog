## 前言

从12306抢火车票到苏宁、天猫抢茅台，定时秒杀的场景在我们生活中已经到处可见。秒杀就是在同一时刻大量大量请求争先抢购同一商品并完成交易的过程。从架构视角来看，整个秒杀系统的难点就是如何在应对流量突发的情况下的保证系统的高性能、高可用、高一致性。 汽车电商的秒杀与一般的电商秒杀系统存在着不一样的特点。

第一，秒杀单品面值大。主机厂在之家商城上提供的现金优惠券平均3-5万，这种大额券会吸引大量职业黑产从业人员进行抢购。

第二，秒杀库存少。优惠力度大，库存数量少，应尽量保证让真正的用户抢到，而不是黑产靠工具刷到。因此整个秒杀系统对风控系统也有着精准风控要求。



## 秒杀系统整体架构

整个电商秒杀系统基于架构的**合适原则、简单原则、演化原则**三原则来设计，通过了解业界秒杀系统的架构以及结合电商系统的现状制定改造计划，分阶段执行。系统整体架构图如下：

![image-20200610225605799](/Users/fangli/github/blog/images/seckill/秒杀系统架构.png)

在秒杀开始前运营人员需要在秒杀管理后台创建一场秒杀活动，设置是否需要预约、预约的开始和结束时间、以及秒杀的开始结束时间。当秒杀活动的预约开始后商品变为不可购买状态，用户只能对商品进行预约。预约后会系统会根据风控中心给出的评分来确定用户是否进入用户id黑名单。

预约结束后秒杀开始前，定时任务会将一些已知道的IP黑名单、用户id黑名单、预约名单、商品信息和活动信息预热到缓存里。当下单请求或者秒杀请求提交到网关层的时候，先会根据商品id查询出当前的商品是否有秒杀活动信息，以及活动的开始时间和结束时间。如果是商品参与了秒杀则进行IP黑名单，用户ID黑名单，预约名单，用户QPS限流的校验，如果都通过则请求缓存对缓存里的库存进行预减缓存库存的操作，如果预减成功则提交请求应用层的订单中心生成秒杀订单。

#### 秒杀模型选择

业界的秒杀模型大致分为两种类型：同步秒杀模型和异步秒杀模型。

同步秒杀模型即抢购后不能立即知道抢购结果，在抢购结果等待页通过轮询后台接口或者与后台的长链接来获取秒杀结果。异步秒杀模型核心思想是利用MQ的削峰，将用户的请求峰值摊平到应用层可以接受的范围。这种模型适合无预约场景，秒杀库存量大，单次秒杀活动订单量大的场景比如直播带货。这种秒杀模型的缺点就是如果用户异步等待时间过长的话会给没有抢到的用户一种有猫腻的感觉，用户体验会差一些。

![image-20200610225605799](/Users/fangli/github/blog/images/seckill/async-model1.png) 



![image-20200610225605799](/Users/fangli/github/blog/images/seckill/async-model2.png)



同步秒杀模型即抢购立刻知道抢购结果，用户体验会好一些。适用于秒杀库存量少，商品价值高，通常需要结合预约、风控系统来完成。业界典型的案例京东、苏宁抢购茅台。

![image-20200610225605799](/Users/fangli/github/blog/images/seckill/sync-model.png)

随着云原生架构技术的不断普及，应用的扩容不再需要运维人员和开发人员来手工操作配置，应用的快速扩容和缩容都可以在秒级内完成。秒杀开始前对应用进行扩容，秒杀结束后对应用进行缩减。相信未来更多的秒杀系统会使用同步秒杀模型。

#### 库存扣减设计

秒杀系统中，库存是个关键数据，卖不出去是个问题，超卖更是个问题。秒杀场景下的一致性问题，主要就是库存扣减的准确性问题。

电商场景下的购买过程一般分为两步：下单和付款。“提交订单”即为下单，“支付订单”即为付款。基于此设定，减库存一般有以下几个方式：

1. 下单减库存。买家下单后，扣减商品库存。下单减库存是最简单的减库存方式，也是控制最为精确的一种
2. 付款减库存。买家下单后，并不立即扣减库存，而是等到付款后才真正扣减库存。但因为付款时才减库存，如果并发比较高，可能出现买家下单后付不了款的情况，因为商品已经被其他人买走了
3. 预扣库存。这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如 15 分钟），超过这段时间，库存自动释放，释放后其他买家可以购买。

综合考虑之后三种减库存的优劣之后我们采取的是下单减库存的方式。下单减库存的优势在于用户体验最好，也是最简单，控制最精确的一种方式。下单时可以直接通过数据库事务机制控制商品库存，所以一定不会出现已下单却付不了款的情况。劣势在于可能卖不出去，但是考虑到实际场景是库存少，面额巨大，一般不会有恶意下单不付款的情况。

## 高性能架构

#### 动静分离

不同秒杀系统架构设计的入口是不一样，可以是商品详情页发起秒杀请求，也可以是购物车发起下单请求。我们的做法是将秒杀的入口放在了商品详情页，带有秒杀标识的商品不允许加入购物车。

在秒杀开始前用户会集中打开详情页，一个html页面还是比较大的，即使做了压缩，http头和内容的大小也可能高达数十K，加上其他的css， js，图片等资源，如果同时有几百万人参与一个商品的抢购，一般机房带宽也就只有1G10G，网络带宽就极有可能成为瓶颈。

由于在抢购过程中，用户在整个页面的关注点只有秒杀倒计时，所以在秒杀开始前可以将商品详情页静态化，并推送到CDN服务器，倒计时组件的时间从服务端的接口取。实现数据意义上的动静分离从而实现前端的高性能。

由于CDN节点遍布全国各地，能缓冲掉绝大部分的压力，而且还比机房带宽便宜。

#### 网关层技术选型

Nginx的高性能是大家公认的，每个工作进程采用了非阻塞I/O来处理多个连接，从而减少了线程上下文切换，从而实现了公认的高性能、高并发，可以轻松达到上万的QPS。

Lua是一种轻量级、可嵌入式的脚本语言，这样可以非常容易的嵌入到其他语言中使用。另外Lua提供了协程并发，即以同步调用的方式进行异步执行，从而实现并发，比起回调机制的并发来说代码更容易编写和理解，排查问题也会容易。Lua的小巧轻量级，可以在Nginx中嵌入Lua VM，请求的时候创建一个VM，请求结束的时候回收VM。

#### 扣减库存

下单减库存在数据一致性上，主要就是保证大并发请求时数据库中的库存字段值不能为负数，一般我们有多种解决方案：一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行SQL语句来报错；再有一种就是使用CASE WHEN判断语句，例如这样的SQL语句：

`UPDATE item SET inventory = CASE WHEN inventory &gt;= xxx THEN inventory-xxx ELSE inventory END`

由于扣减库存不仅有更新商品库存操作，也有写入日志等SQL操作。所以做法有两种：

方法1

```
start transaction
insert change_log
update stock set num=num-? where sku_id=？and num>=0;
end  transaction
```

方法2

```
Start transaction
update stock set num=num-? where sku_id=？and num>=0;
insert change_log
end  transaction
```

由于MySQL存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有大量线程来竞争InnoDB行锁，而并发度越高时等待线程会越多，TPS会下降，响应时间（RT）会上升，数据库的吞吐量就会严重受影响。所以推荐使用方法1。如果change_log表数据量很大，写入耗时性能较差，可以考虑定期对历史数据进行归档。

## 高可用

稳定性是一个平时不重要，但出了问题就要命的事情。保证秒杀系统的高可用是需要重点关注的。

#### 分层限流

盯过秒杀流量监控的话，会发现它不是一条蜿蜒而起的曲线，而是一条挺拔的直线，这是因为秒杀请求高度集中于某一特定的时间点。这样一来就会造成一个特别高的零点峰值，而对资源的消耗也几乎是瞬时的。但是库存又很少，所以我们需要分层限流，将尽可能少的请求拦截到应用层之前。

![image-20200610225605799](/Users/fangli/github/blog/images/seckill/分层限流.png)

#### 缓存高可用

在上面提到的分层限流中，多数我们都使用到了缓存，缓存的高可用性将影响到整个系统的高可用性。缓存系统采用开源的codis架构。通过分片实现容量扩展，通过主从复制实现节点的高可用。

一个codis实例可以连接多个redis实例，也可以启动多个codis实例来支撑，每个codis节点都是对等的，这样可以增加整体的QPS需求，还能起到容灾功能。



#### 热点隔离

在Redis中存储秒杀商品的库存数量时，可以将秒杀商品的库存进行“分割”存储来提升Redis的读写并发量。

例如，原来的秒杀商品的id为10001，库存为10件，在Redis中的存储为(10001, 2)，我们将原有的库存分割为5份，则每份的库存为2件，此时，我们在Redis中存储的信息为(10001_0, 2)，(10001_1, 2)，(10001_2, 2)，(10001_3, 2)，(10001_4, 2)。



![image-20200610225605799](/Users/fangli/github/blog/images/seckill/缓存库存设计.png)



另外库存分片也能够有效的缓解redis的热点key问题，codis是按key进行分槽存储，将同一库存的key分散到不同的codis组里，可以有效的平衡整个集群中各组的访问量。

#### 双活部署





#### 隔离部署





#### 限流隔离熔断





#### 兜底方案

当一个系统面临持续的高峰流量时，其实是很难单靠自身调整来恢复状态的，日常运维没有人能够预估所有情况，意外总是无法避免。尤其在秒杀这一场景下，为了保证系统的高可用，必须设计一个 Plan B 方案来进行兜底。

高可用建设，其实是一个系统工程，贯穿在系统建设的整个生命周期。

具体来说，系统的高可用建设涉及架构阶段、编码阶段、测试阶段、发布阶段、运行阶段，以及故障发生时，逐一进行分析：

1. 架构阶段：考虑系统的可扩展性和容错性，避免出现单点问题。例如多地单元化部署，即使某个IDC甚至地市出现故障，仍不会影响系统运转
2. 编码阶段：保证代码的健壮性，例如RPC调用时，设置合理的超时退出机制，防止被其他系统拖垮，同时也要对无法预料的返回错误进行默认的处理
3. 测试阶段：保证CI的覆盖度以及Sonar的容错率，对基础质量进行二次校验，并定期产出整体质量的趋势报告
4. 发布阶段：系统部署最容易暴露错误，因此要有前置的checklist模版、中置的上下游周知机制以及后置的回滚机制
5. 运行阶段：系统多数时间处于运行态，最重要的是运行时的实时监控，及时发现问题、准确报警并能提供详细数据，以便排查问题
6. 故障发生：首要目标是及时止损，防止影响面扩大，然后定位原因、解决问题，最后恢复服务

对于日常运维而言，高可用更多是针对运行阶段而言的，此阶段需要额外进行加强建设，主要有以下几种手段：

1. 预防：建立常态压测体系，定期对服务进行单点压测以及全链路压测，摸排水位
2. 管控：做好线上运行的降级、限流和熔断保护。需要注意的是，无论是限流、降级还是熔断，对业务都是有损的，所以在进行操作前，一定要和上下游业务确认好再进行。就拿限流来说，哪些业务可以限、什么情况下限、限流时间多长、什么情况下进行恢复，都要和业务方反复确认
3. 监控：建立性能基线，记录性能的变化趋势；建立报警体系，发现问题及时预警
4. 恢复：遇到故障能够及时止损，并提供快速的数据订正工具，不一定要好，但一定要有

在系统建设的整个生命周期中，每个环节中都可能犯错，甚至有些环节犯的错，后面是无法弥补的或者成本极高的。所以高可用是一个系统工程，必须放到整个生命周期中进行全面考虑。同时，考虑到服务的增长性，高可用更需要长期规划并进行体系化建设。





## 安全架构

#### 预约风控机制

将厂商旗舰店的购车权益发放到真实的购车用户手里，这是整个车电商秒杀系统的核心关注点。当用户点击预约后台生成预约记录之后，会异步请求之家的用户风控接口，此风控接口结合了用户在之家的行为轨迹、用户画像、以及在全网内的信誉评分（第三方提供）等维度给用户给一个风险评估分，高于风险阈值的用户将会被直接拉到用户黑名单。

#### 用户行为风控

经过多次秒杀之后的复盘验证之后我们发现一个问题，就是黑产直接跳过了结算页，直接访问的下单URL，这样就显得对普通用户不公平。我们的做法是在秒杀的结算页生成token，当用户提交到下单页的是时候判断是否有token以及token生成的时间是否大于1s（结算页需要输入用户手机号和姓名）。通过用户行为风控来将真正的黑产拒之门外。



## 总结

一个秒杀系统的设计，可以根据不同级别的流量，由简单到复杂打造出不同的架构，本质是各方面的取舍和权衡。

作为架构师，应该时刻提醒自己主线是什么。遵循简单原则、迭代原则。



## 附架构评审的问题

**为什么没有设计答题、排队、验证码系统来削峰**？

答题、排队、验证码可以人为拉长峰值下单的时长，由之前的 <1s 延长到 <10s。这个时间对于服务端非常重要，会大大减轻高峰期并发压力。并且能够难道一些爬虫用户，但是并不能拦住专业的黑产用户。在秒杀系统上了之家云Docker集群后，综合考虑性能、用户体验，将秒杀排队的机制给去掉，减少真正的用户的提交秒杀请求的时间。

**为什么没有使用动态URL**

综合分析发现动态url的带来的ROI成本低，生成的url需要存储在缓存里，对缓存也是多了一层压力。

**为什么没有使用mq来削峰**

根据奥卡姆剃刀原则如非必要，不要引入新的实体。

**秒杀系统容易出问题的点**

应用突增的网络及服务器宽带、以及需要提前评估好codis集群的容量以及网络带宽。